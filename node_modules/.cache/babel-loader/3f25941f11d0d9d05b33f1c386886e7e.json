{"ast":null,"code":"var _jsxFileName = \"/Users/eyo/Desktop/expense-tracker/src/store/searchListData/SearchListDataProvider.js\",\n    _s = $RefreshSig$();\n\nimport { useReducer, useContext, useEffect } from \"react\";\nimport compareTimeWithRange from \"../../Others/CompareTime/compareTimeWithRange\";\nimport ExpenseDataContext from \"../expenseData/expenseData--context\";\nimport SearchListDataContext from \"./searchListData--context\";\nimport { db } from \"../../firebase-config\";\nimport { collection, onSnapshot, doc, addDoc, deleteDoc, updateDoc } from \"firebase/firestore\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet originalData;\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"ADD\":\n      {\n        const newConstraintObj = { ...state.constraintObj\n        };\n        /*\n        the reason need id (time, category, price)\n        => seperate differen filterd arr\n         the reason need value\n        => make each filtered option being unique, so that we won't cover old data, and also can remove easily\n        */\n\n        newConstraintObj[`${action.id}-${action.value}`] = action.value;\n        return {\n          expenseData: reducerHelperFunction(newConstraintObj, originalData),\n          constraintObj: newConstraintObj\n        };\n      }\n\n    case \"REMOVE\":\n      {\n        const newConstraintObj = { ...state.constraintObj\n        }; // because id + value, it can be easily removed\n\n        delete newConstraintObj[`${action.id}-${action.value}`];\n        let newState;\n        if (Object.keys(newConstraintObj).length === 0) newState = originalData;else {\n          newState = reducerHelperFunction(newConstraintObj, originalData);\n        }\n        return {\n          expenseData: newState,\n          constraintObj: newConstraintObj\n        };\n      }\n\n    case \"SEARCH\":\n      {\n        let newState;\n        if (action.value.length === 0) newState = originalData;else {\n          newState = state.expenseData.filter(element => element.description.includes(action.value));\n        }\n        return {\n          expenseData: newState,\n          constraintObj: state.constraintObj\n        };\n      }\n\n    case \"SORT_TIME\":\n      {\n        let newState;\n        if (action.sort) newState = state.expenseData.sort((elementA, elementB) => Number(new Date(elementA.time)) - Number(new Date(elementB.time)));else newState = state.expenseData.sort((elementA, elementB) => Number(new Date(elementB.time)) - Number(new Date(elementA.time)));\n        return {\n          expenseData: newState,\n          constraintObj: state.constraintObj\n        };\n      }\n\n    case \"SORT_PRICE\":\n      {\n        let newState;\n        if (action.sort) newState = state.expenseData.sort((elementA, elementB) => Number(elementA.price) - Number(elementB.price));else newState = state.expenseData.sort((elementA, elementB) => Number(elementB.price) - Number(elementA.price));\n        return {\n          expenseData: newState,\n          constraintObj: state.constraintObj\n        };\n      }\n\n    case \"SORT_CATEGORY\":\n      {\n        const incomeDataArr = state.expenseData.filter(element => element.category === \"income\");\n        const expenseDataArr = state.expenseData.filter(element => element.category === \"expense\");\n        let newState;\n        if (action.sort) newState = [...incomeDataArr, ...expenseDataArr];else newState = [...expenseDataArr, ...incomeDataArr];\n        return {\n          expenseData: newState,\n          constraintObj: state.constraintObj\n        };\n      }\n\n    case \"DELETE\":\n      {\n        const newState = state.expenseData.filter(element => element.id !== action.id);\n        return { ...state,\n          expenseData: newState\n        };\n      }\n\n    default:\n      return state;\n  }\n}\n\nfunction SearchListDataProvider(props) {\n  _s();\n\n  const expenseDataCollectionRef = collection(db, \"expense-data\");\n  const {\n    expenseData\n  } = useContext(ExpenseDataContext);\n  const [filteredData, setFilteredData] = useReducer(reducer, {\n    constraintObj: {},\n    expenseData: expenseData\n  });\n  originalData = expenseData;\n  useEffect(() => {\n    onSnapshot(expenseDataCollectionRef, snapshot => {\n      setExpenseData(snapshot.docs.map(doc => ({ ...doc.data(),\n        id: doc.id\n      })));\n    });\n  }, []);\n  const SearchListDataContextInitialObject = {\n    setFilteredData,\n    expenseData: filteredData.expenseData\n  };\n  return /*#__PURE__*/_jsxDEV(SearchListDataContext.Provider, {\n    value: SearchListDataContextInitialObject,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 152,\n    columnNumber: 5\n  }, this);\n}\n\n_s(SearchListDataProvider, \"Enh58rbPvCBhNKYzBtlrWrX9C4I=\");\n\n_c = SearchListDataProvider;\n\nfunction filterTime(expenseData, filterArr) {\n  if (filterArr.length === 0) return expenseData; // all we need is the first day and last day within the vaild date range(filterArr)\n\n  let firstDay = Infinity,\n      lastDay = -Infinity;\n  filterArr.forEach(filteredData => {\n    const [first, last] = filteredData.split(\",\");\n    firstDay = new Date(Math.min(firstDay, Number(new Date(first))));\n    lastDay = new Date(Math.max(lastDay, Number(new Date(last))));\n  });\n  const filteredData = expenseData.filter(data => compareTimeWithRange(data, firstDay, lastDay));\n  return filteredData;\n}\n\nfunction filterPrice(data, filterArr) {\n  if (filterArr.length === 0) return data;\n  let min = Infinity;\n  let max = 0;\n  let tmpMin;\n  let tmpMax;\n  const newFilterArr = filterArr.map(arr => arr.split(\",\"));\n  newFilterArr.forEach(element => {\n    [tmpMin, tmpMax] = element;\n    min = Math.min(min, Number(tmpMin), Number(tmpMax));\n    max = Math.max(max, Number(tmpMin), Number(tmpMax));\n  });\n  return data.filter(element => Number(element.price) >= min && Number(element.price) <= max);\n}\n\nfunction filterCategory(data, filterArr) {\n  if (filterArr.length === 0) return data;\n  return data.filter(element => filterArr.includes(element.mainCate));\n}\n\nfunction reducerHelperFunction(constraintObj, expenseData) {\n  let timeArr = [];\n  let priceArr = [];\n  let categoryArr = [];\n\n  for (const [key, val] of Object.entries(constraintObj)) {\n    const [type] = key.split(\"-\");\n    if (type === \"category\") categoryArr.push(val);else if (type === \"price\") priceArr.push(val);else timeArr.push(val);\n  }\n\n  return filterCategory(filterPrice(filterTime(expenseData, timeArr), priceArr), categoryArr);\n}\n\nexport default SearchListDataProvider;\n/*\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"TIME\": {\n      return reducerTime(state, action);\n    }\n\n    case \"PRICE\": {\n      return reducerPrice(state, action);\n    }\n\n    case \"CATEGORY\": {\n      return reducerCategory(state, action);\n    }\n\n    default:\n      break;\n  }\n}\n\nfunction reducerCategory(state, action) {\n  let newState;\n  let totalCount = state.checkTotalCount;\n  let categoryCount = state.checkCategoryCount;\n\n  if (action.checked) {\n    if (totalCount === 0) {\n      totalCount++;\n      categoryCount++;\n\n      newState = state.expenseData.filter(\n        (element) => element.mainCate === action.value\n      );\n    } else {\n      totalCount++;\n      categoryCount++;\n\n      if (state.checkPriceCount !== 0 || state.checkTimeCount !== 0) {\n        newState = state.expenseData.filter(\n          (element) => element.mainCate === action.value\n        );\n      } else {\n        const concatArr = orginalObj.filter(\n          (element) => element.mainCate === action.value\n        );\n\n        newState = state.expenseData.concat(concatArr);\n      }\n    }\n  } else {\n    totalCount--;\n    categoryCount--;\n\n    if (totalCount === 0) newState = orginalObj;\n    else {\n      newState = state.expenseData.filter(\n        (element) => element.mainCate !== action.value\n      );\n    }\n  }\n\n  return {\n    checkTotalCount: totalCount,\n    checkTimeCount: state.checkTimeCount,\n    checkPriceCount: state.checkPriceCount,\n    checkCategoryCount: categoryCount,\n    expenseData: newState,\n  };\n}\n\nfunction reducerPrice(state, action) {\n  const [lowestPrice, highestPrice] = action.value.split(\",\");\n  let newState;\n  let totalCount = state.checkTotalCount;\n  let priceCount = state.checkPriceCount;\n\n  if (action.checked) {\n    if (totalCount === 0) {\n      totalCount++;\n      priceCount++;\n\n      newState = state.expenseData.filter(\n        (element) =>\n          Number(element.price) >= lowestPrice &&\n          Number(element.price) <= highestPrice\n      );\n    } else {\n      totalCount++;\n      priceCount++;\n\n      if (state.checkTimeCount !== 0 || state.checkCategoryCount !== 0) {\n        newState = state.expenseData.filter(\n          (element) =>\n            Number(element.price) >= lowestPrice &&\n            Number(element.price) <= highestPrice\n        );\n      } else {\n        const concatArr = orginalObj.filter(\n          (element) =>\n            Number(element.price) >= lowestPrice &&\n            Number(element.price) <= highestPrice\n        );\n\n        newState = state.expenseData.concat(concatArr);\n      }\n    }\n  } else {\n    totalCount--;\n    priceCount--;\n\n    if (totalCount === 0) newState = orginalObj;\n    else {\n      newState = state.expenseData.filter(\n        (element) =>\n          Number(element.price) < lowestPrice ||\n          Number(element.price) > highestPrice\n      );\n    }\n  }\n\n  return {\n    checkTotalCount: totalCount,\n    checkTimeCount: state.checkTimeCount,\n    checkPriceCount: priceCount,\n    checkCategoryCount: state.checkCategoryCount,\n    expenseData: newState,\n  };\n}\n\nfunction reducerTime(state, action) {\n  let dateArr = [];\n  let newState;\n\n  // days\n  if (action.value < 30) {\n    const currenDate = date.getDate();\n\n    if (action.value === 0) dateArr.push(currenDate);\n    else\n      for (let i = 1; i <= action.value; i++) {\n        dateArr.push(currenDate - i);\n      }\n\n    if (action.checked) {\n      newState = state.expenseData.filter(\n        (element) =>\n          dateArr.includes(Number(element.time.slice(8))) &&\n          Number(element.time.slice(5, 7)) === date.getMonth() + 1\n      );\n    } else {\n      const concatArr = orginalObj.filter(\n        (element) =>\n          !dateArr.includes(Number(element.time.slice(8))) ||\n          !(Number(element.time.slice(5, 7)) === date.getMonth() + 1)\n      );\n\n      newState = state.expenseData.concat(concatArr);\n    }\n  }\n  // months\n  else if (action.value === 30 || action.value === 90) {\n    if (action.value === 30) dateArr.push(date.getMonth());\n    else {\n      for (let i = 0; i < 3; i++) {\n        dateArr.push(date.getMonth() - i);\n      }\n    }\n\n    if (action.checked) {\n      newState = state.expenseData.filter((element) =>\n        dateArr.includes(Number(element.time.slice(5, 7)))\n      );\n    } else {\n      const concatArr = orginalObj.filter(\n        (element) => !dateArr.includes(Number(element.time.slice(5, 7)))\n      );\n\n      newState = state.expenseData.concat(concatArr);\n    }\n  }\n  // years\n  else {\n    dateArr.push(date.getFullYear() - 1);\n\n    if (action.checked) {\n      newState = state.expenseData.filter((element) =>\n        dateArr.includes(Number(element.time.slice(0, 4)))\n      );\n    } else {\n      const concatArr = orginalObj.filter(\n        (element) => !dateArr.includes(Number(element.time.slice(0, 4)))\n      );\n\n      newState = state.expenseData.concat(concatArr);\n    }\n  }\n\n  return { ...state, expenseData: newState };\n}\n\nconst checkboxTime = [\n  { category: \"time\", text: \"today\", value: 0, checked: false },\n  { category: \"time\", text: \"yesterady\", value: 1, checked: false },\n  { category: \"time\", text: \"three days ago\", value: 3, checked: false },\n  { category: \"time\", text: \"a week ago\", value: 7, checked: false },\n  { category: \"time\", text: \"a month ago\", value: 30, checked: false },\n  { category: \"time\", text: \"three months ago\", value: 90, checked: false },\n  { category: \"time\", text: \"a year ago\", value: 100, checked: false },\n  { category: \"price\", text: \"0 ~ $100\", value: [0, 100], checked: false },\n  { category: \"price\", text: \"$100 ~ $300\", value: [100, 300], checked: false },\n  { category: \"price\", text: \"$300 ~ $500\", value: [300, 500], checked: false },\n  {\n    category: \"price\",\n    text: \"$500 ~ $1000\",\n    value: [500, 1000],\n    checked: false,\n  },\n  {\n    category: \"price\",\n    text: \"above $1000\",\n    value: [1000, Infinity],\n    checked: false,\n  },\n];\n\n*/\n\n/*\nfunction filterTime(data, filterArr) {\n  return data;\n  // no filter, just return all data\n  if (filterArr.length === 0) return data;\n\n  const date = new Date();\n  let dayArr = [Infinity, 0];\n  let monthArr = [Infinity, 0];\n  let yearArr = [];\n  let tmpA, tmpB, tmpC;\n\n  filterArr.forEach((element) => {\n    if (element[0] === \"d\") {\n      [tmpA, tmpB, tmpC] = element.split(\",\");\n\n      if (Number(tmpC) < dayArr[0]) dayArr[0] = Number(tmpC);\n      if (Number(tmpB) > dayArr[1]) dayArr[1] = Number(tmpB);\n    }\n    if (element[0] === \"m\") {\n      [tmpA, tmpB, tmpC] = element.split(\",\");\n\n      if (Number(tmpC) < monthArr[0]) monthArr[0] = Number(tmpC);\n      if (Number(tmpB) > monthArr[1]) monthArr[1] = Number(tmpB);\n    }\n    if (element[0] === \"y\") yearArr.push(element.split(\",\")[1]);\n  });\n\n  let filteredData = [];\n\n  // if only having day-base array, then check 1) year 2) month 3) range of day\n  if (monthArr[0] === Infinity && monthArr[1] === 0 && yearArr.length === 0) {\n    filteredData = data.filter(\n      (element) =>\n        Number(element.time.slice(0, 4)) === date.getFullYear() &&\n        Number(element.time.slice(5, 7)) === date.getMonth() + 1 &&\n        Number(element.time.slice(8)) <= dayArr[1] &&\n        Number(element.time.slice(8)) >= dayArr[0]\n    );\n  }\n\n  // if having month-base array and not having year-base array, then we only need to check 1) year 2) month\n  if (monthArr[0] !== Infinity && monthArr[1] !== 0 && yearArr.length === 0) {\n    filteredData = data.filter(\n      (element) =>\n        Number(element.time.slice(0, 4)) === date.getFullYear() &&\n        Number(element.time.slice(5, 7)) <= Number(monthArr[1]) &&\n        Number(element.time.slice(5, 7)) >= Number(monthArr[0])\n    );\n  }\n\n  // if having year-base array, then only need to check 1) year\n  if (yearArr.length !== 0) {\n    filteredData = data.filter((element) =>\n      yearArr.includes(element.time.slice(0, 4))\n    );\n  }\n\n  return filteredData;\n}\n*/\n\nvar _c;\n\n$RefreshReg$(_c, \"SearchListDataProvider\");","map":{"version":3,"sources":["/Users/eyo/Desktop/expense-tracker/src/store/searchListData/SearchListDataProvider.js"],"names":["useReducer","useContext","useEffect","compareTimeWithRange","ExpenseDataContext","SearchListDataContext","db","collection","onSnapshot","doc","addDoc","deleteDoc","updateDoc","originalData","reducer","state","action","type","newConstraintObj","constraintObj","id","value","expenseData","reducerHelperFunction","newState","Object","keys","length","filter","element","description","includes","sort","elementA","elementB","Number","Date","time","price","incomeDataArr","category","expenseDataArr","SearchListDataProvider","props","expenseDataCollectionRef","filteredData","setFilteredData","snapshot","setExpenseData","docs","map","data","SearchListDataContextInitialObject","children","filterTime","filterArr","firstDay","Infinity","lastDay","forEach","first","last","split","Math","min","max","filterPrice","tmpMin","tmpMax","newFilterArr","arr","filterCategory","mainCate","timeArr","priceArr","categoryArr","key","val","entries","push"],"mappings":"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AJ,CAAU,GAAV,CAAf;AAEA,QAAI7C,IAAI,KAAK,UAAb,EAAyB0D,WAAW,CAACI,IAAZ,CAAiBF,GAAjB,EAAzB,KACK,IAAI5D,IAAI,KAAK,OAAb,EAAsByD,QAAQ,CAACK,IAAT,CAAcF,GAAd,EAAtB,KACAJ,OAAO,CAACM,IAAR,CAAaF,GAAb;AACN;;AAED,SAAON,cAAc,CACnBL,WAAW,CAACZ,UAAU,CAAChC,WAAD,EAAcmD,OAAd,CAAX,EAAmCC,QAAnC,CADQ,EAEnBC,WAFmB,CAArB;AAID;;AAED,eAAejC,sBAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { useReducer, useContext, useEffect } from \"react\";\nimport compareTimeWithRange from \"../../Others/CompareTime/compareTimeWithRange\";\nimport ExpenseDataContext from \"../expenseData/expenseData--context\";\nimport SearchListDataContext from \"./searchListData--context\";\nimport { db } from \"../../firebase-config\";\nimport {\n  collection,\n  onSnapshot,\n  doc,\n  addDoc,\n  deleteDoc,\n  updateDoc,\n} from \"firebase/firestore\";\nlet originalData;\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"ADD\": {\n      const newConstraintObj = { ...state.constraintObj };\n\n      /*\n      the reason need id (time, category, price)\n      => seperate differen filterd arr\n\n      the reason need value\n      => make each filtered option being unique, so that we won't cover old data, and also can remove easily\n      */\n      newConstraintObj[`${action.id}-${action.value}`] = action.value;\n\n      return {\n        expenseData: reducerHelperFunction(newConstraintObj, originalData),\n        constraintObj: newConstraintObj,\n      };\n    }\n\n    case \"REMOVE\": {\n      const newConstraintObj = { ...state.constraintObj };\n\n      // because id + value, it can be easily removed\n      delete newConstraintObj[`${action.id}-${action.value}`];\n\n      let newState;\n      if (Object.keys(newConstraintObj).length === 0) newState = originalData;\n      else {\n        newState = reducerHelperFunction(newConstraintObj, originalData);\n      }\n\n      return { expenseData: newState, constraintObj: newConstraintObj };\n    }\n\n    case \"SEARCH\": {\n      let newState;\n\n      if (action.value.length === 0) newState = originalData;\n      else {\n        newState = state.expenseData.filter((element) =>\n          element.description.includes(action.value)\n        );\n      }\n\n      return { expenseData: newState, constraintObj: state.constraintObj };\n    }\n\n    case \"SORT_TIME\": {\n      let newState;\n\n      if (action.sort)\n        newState = state.expenseData.sort(\n          (elementA, elementB) =>\n            Number(new Date(elementA.time)) - Number(new Date(elementB.time))\n        );\n      else\n        newState = state.expenseData.sort(\n          (elementA, elementB) =>\n            Number(new Date(elementB.time)) - Number(new Date(elementA.time))\n        );\n\n      return { expenseData: newState, constraintObj: state.constraintObj };\n    }\n\n    case \"SORT_PRICE\": {\n      let newState;\n\n      if (action.sort)\n        newState = state.expenseData.sort(\n          (elementA, elementB) =>\n            Number(elementA.price) - Number(elementB.price)\n        );\n      else\n        newState = state.expenseData.sort(\n          (elementA, elementB) =>\n            Number(elementB.price) - Number(elementA.price)\n        );\n\n      return { expenseData: newState, constraintObj: state.constraintObj };\n    }\n\n    case \"SORT_CATEGORY\": {\n      const incomeDataArr = state.expenseData.filter(\n        (element) => element.category === \"income\"\n      );\n\n      const expenseDataArr = state.expenseData.filter(\n        (element) => element.category === \"expense\"\n      );\n\n      let newState;\n\n      if (action.sort) newState = [...incomeDataArr, ...expenseDataArr];\n      else newState = [...expenseDataArr, ...incomeDataArr];\n\n      return { expenseData: newState, constraintObj: state.constraintObj };\n    }\n\n    case \"DELETE\": {\n      const newState = state.expenseData.filter(\n        (element) => element.id !== action.id\n      );\n\n      return { ...state, expenseData: newState };\n    }\n\n    default:\n      return state;\n  }\n}\n\nfunction SearchListDataProvider(props) {\n  const expenseDataCollectionRef = collection(db, \"expense-data\");\n  const { expenseData } = useContext(ExpenseDataContext);\n  const [filteredData, setFilteredData] = useReducer(reducer, {\n    constraintObj: {},\n    expenseData: expenseData,\n  });\n\n  originalData = expenseData;\n\n  useEffect(() => {\n    onSnapshot(expenseDataCollectionRef, (snapshot) => {\n      setExpenseData(\n        snapshot.docs.map((doc) => ({ ...doc.data(), id: doc.id }))\n      );\n    });\n  }, []);\n\n  const SearchListDataContextInitialObject = {\n    setFilteredData,\n    expenseData: filteredData.expenseData,\n  };\n\n  return (\n    <SearchListDataContext.Provider value={SearchListDataContextInitialObject}>\n      {props.children}\n    </SearchListDataContext.Provider>\n  );\n}\n\nfunction filterTime(expenseData, filterArr) {\n  if (filterArr.length === 0) return expenseData;\n\n  // all we need is the first day and last day within the vaild date range(filterArr)\n  let firstDay = Infinity,\n    lastDay = -Infinity;\n\n  filterArr.forEach((filteredData) => {\n    const [first, last] = filteredData.split(\",\");\n\n    firstDay = new Date(Math.min(firstDay, Number(new Date(first))));\n    lastDay = new Date(Math.max(lastDay, Number(new Date(last))));\n  });\n\n  const filteredData = expenseData.filter((data) =>\n    compareTimeWithRange(data, firstDay, lastDay)\n  );\n\n  return filteredData;\n}\n\nfunction filterPrice(data, filterArr) {\n  if (filterArr.length === 0) return data;\n\n  let min = Infinity;\n  let max = 0;\n  let tmpMin;\n  let tmpMax;\n  const newFilterArr = filterArr.map((arr) => arr.split(\",\"));\n\n  newFilterArr.forEach((element) => {\n    [tmpMin, tmpMax] = element;\n\n    min = Math.min(min, Number(tmpMin), Number(tmpMax));\n    max = Math.max(max, Number(tmpMin), Number(tmpMax));\n  });\n\n  return data.filter(\n    (element) => Number(element.price) >= min && Number(element.price) <= max\n  );\n}\n\nfunction filterCategory(data, filterArr) {\n  if (filterArr.length === 0) return data;\n\n  return data.filter((element) => filterArr.includes(element.mainCate));\n}\n\nfunction reducerHelperFunction(constraintObj, expenseData) {\n  let timeArr = [];\n  let priceArr = [];\n  let categoryArr = [];\n\n  for (const [key, val] of Object.entries(constraintObj)) {\n    const [type] = key.split(\"-\");\n\n    if (type === \"category\") categoryArr.push(val);\n    else if (type === \"price\") priceArr.push(val);\n    else timeArr.push(val);\n  }\n\n  return filterCategory(\n    filterPrice(filterTime(expenseData, timeArr), priceArr),\n    categoryArr\n  );\n}\n\nexport default SearchListDataProvider;\n\n/*\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"TIME\": {\n      return reducerTime(state, action);\n    }\n\n    case \"PRICE\": {\n      return reducerPrice(state, action);\n    }\n\n    case \"CATEGORY\": {\n      return reducerCategory(state, action);\n    }\n\n    default:\n      break;\n  }\n}\n\nfunction reducerCategory(state, action) {\n  let newState;\n  let totalCount = state.checkTotalCount;\n  let categoryCount = state.checkCategoryCount;\n\n  if (action.checked) {\n    if (totalCount === 0) {\n      totalCount++;\n      categoryCount++;\n\n      newState = state.expenseData.filter(\n        (element) => element.mainCate === action.value\n      );\n    } else {\n      totalCount++;\n      categoryCount++;\n\n      if (state.checkPriceCount !== 0 || state.checkTimeCount !== 0) {\n        newState = state.expenseData.filter(\n          (element) => element.mainCate === action.value\n        );\n      } else {\n        const concatArr = orginalObj.filter(\n          (element) => element.mainCate === action.value\n        );\n\n        newState = state.expenseData.concat(concatArr);\n      }\n    }\n  } else {\n    totalCount--;\n    categoryCount--;\n\n    if (totalCount === 0) newState = orginalObj;\n    else {\n      newState = state.expenseData.filter(\n        (element) => element.mainCate !== action.value\n      );\n    }\n  }\n\n  return {\n    checkTotalCount: totalCount,\n    checkTimeCount: state.checkTimeCount,\n    checkPriceCount: state.checkPriceCount,\n    checkCategoryCount: categoryCount,\n    expenseData: newState,\n  };\n}\n\nfunction reducerPrice(state, action) {\n  const [lowestPrice, highestPrice] = action.value.split(\",\");\n  let newState;\n  let totalCount = state.checkTotalCount;\n  let priceCount = state.checkPriceCount;\n\n  if (action.checked) {\n    if (totalCount === 0) {\n      totalCount++;\n      priceCount++;\n\n      newState = state.expenseData.filter(\n        (element) =>\n          Number(element.price) >= lowestPrice &&\n          Number(element.price) <= highestPrice\n      );\n    } else {\n      totalCount++;\n      priceCount++;\n\n      if (state.checkTimeCount !== 0 || state.checkCategoryCount !== 0) {\n        newState = state.expenseData.filter(\n          (element) =>\n            Number(element.price) >= lowestPrice &&\n            Number(element.price) <= highestPrice\n        );\n      } else {\n        const concatArr = orginalObj.filter(\n          (element) =>\n            Number(element.price) >= lowestPrice &&\n            Number(element.price) <= highestPrice\n        );\n\n        newState = state.expenseData.concat(concatArr);\n      }\n    }\n  } else {\n    totalCount--;\n    priceCount--;\n\n    if (totalCount === 0) newState = orginalObj;\n    else {\n      newState = state.expenseData.filter(\n        (element) =>\n          Number(element.price) < lowestPrice ||\n          Number(element.price) > highestPrice\n      );\n    }\n  }\n\n  return {\n    checkTotalCount: totalCount,\n    checkTimeCount: state.checkTimeCount,\n    checkPriceCount: priceCount,\n    checkCategoryCount: state.checkCategoryCount,\n    expenseData: newState,\n  };\n}\n\nfunction reducerTime(state, action) {\n  let dateArr = [];\n  let newState;\n\n  // days\n  if (action.value < 30) {\n    const currenDate = date.getDate();\n\n    if (action.value === 0) dateArr.push(currenDate);\n    else\n      for (let i = 1; i <= action.value; i++) {\n        dateArr.push(currenDate - i);\n      }\n\n    if (action.checked) {\n      newState = state.expenseData.filter(\n        (element) =>\n          dateArr.includes(Number(element.time.slice(8))) &&\n          Number(element.time.slice(5, 7)) === date.getMonth() + 1\n      );\n    } else {\n      const concatArr = orginalObj.filter(\n        (element) =>\n          !dateArr.includes(Number(element.time.slice(8))) ||\n          !(Number(element.time.slice(5, 7)) === date.getMonth() + 1)\n      );\n\n      newState = state.expenseData.concat(concatArr);\n    }\n  }\n  // months\n  else if (action.value === 30 || action.value === 90) {\n    if (action.value === 30) dateArr.push(date.getMonth());\n    else {\n      for (let i = 0; i < 3; i++) {\n        dateArr.push(date.getMonth() - i);\n      }\n    }\n\n    if (action.checked) {\n      newState = state.expenseData.filter((element) =>\n        dateArr.includes(Number(element.time.slice(5, 7)))\n      );\n    } else {\n      const concatArr = orginalObj.filter(\n        (element) => !dateArr.includes(Number(element.time.slice(5, 7)))\n      );\n\n      newState = state.expenseData.concat(concatArr);\n    }\n  }\n  // years\n  else {\n    dateArr.push(date.getFullYear() - 1);\n\n    if (action.checked) {\n      newState = state.expenseData.filter((element) =>\n        dateArr.includes(Number(element.time.slice(0, 4)))\n      );\n    } else {\n      const concatArr = orginalObj.filter(\n        (element) => !dateArr.includes(Number(element.time.slice(0, 4)))\n      );\n\n      newState = state.expenseData.concat(concatArr);\n    }\n  }\n\n  return { ...state, expenseData: newState };\n}\n\nconst checkboxTime = [\n  { category: \"time\", text: \"today\", value: 0, checked: false },\n  { category: \"time\", text: \"yesterady\", value: 1, checked: false },\n  { category: \"time\", text: \"three days ago\", value: 3, checked: false },\n  { category: \"time\", text: \"a week ago\", value: 7, checked: false },\n  { category: \"time\", text: \"a month ago\", value: 30, checked: false },\n  { category: \"time\", text: \"three months ago\", value: 90, checked: false },\n  { category: \"time\", text: \"a year ago\", value: 100, checked: false },\n  { category: \"price\", text: \"0 ~ $100\", value: [0, 100], checked: false },\n  { category: \"price\", text: \"$100 ~ $300\", value: [100, 300], checked: false },\n  { category: \"price\", text: \"$300 ~ $500\", value: [300, 500], checked: false },\n  {\n    category: \"price\",\n    text: \"$500 ~ $1000\",\n    value: [500, 1000],\n    checked: false,\n  },\n  {\n    category: \"price\",\n    text: \"above $1000\",\n    value: [1000, Infinity],\n    checked: false,\n  },\n];\n\n*/\n/*\nfunction filterTime(data, filterArr) {\n  return data;\n  // no filter, just return all data\n  if (filterArr.length === 0) return data;\n\n  const date = new Date();\n  let dayArr = [Infinity, 0];\n  let monthArr = [Infinity, 0];\n  let yearArr = [];\n  let tmpA, tmpB, tmpC;\n\n  filterArr.forEach((element) => {\n    if (element[0] === \"d\") {\n      [tmpA, tmpB, tmpC] = element.split(\",\");\n\n      if (Number(tmpC) < dayArr[0]) dayArr[0] = Number(tmpC);\n      if (Number(tmpB) > dayArr[1]) dayArr[1] = Number(tmpB);\n    }\n    if (element[0] === \"m\") {\n      [tmpA, tmpB, tmpC] = element.split(\",\");\n\n      if (Number(tmpC) < monthArr[0]) monthArr[0] = Number(tmpC);\n      if (Number(tmpB) > monthArr[1]) monthArr[1] = Number(tmpB);\n    }\n    if (element[0] === \"y\") yearArr.push(element.split(\",\")[1]);\n  });\n\n  let filteredData = [];\n\n  // if only having day-base array, then check 1) year 2) month 3) range of day\n  if (monthArr[0] === Infinity && monthArr[1] === 0 && yearArr.length === 0) {\n    filteredData = data.filter(\n      (element) =>\n        Number(element.time.slice(0, 4)) === date.getFullYear() &&\n        Number(element.time.slice(5, 7)) === date.getMonth() + 1 &&\n        Number(element.time.slice(8)) <= dayArr[1] &&\n        Number(element.time.slice(8)) >= dayArr[0]\n    );\n  }\n\n  // if having month-base array and not having year-base array, then we only need to check 1) year 2) month\n  if (monthArr[0] !== Infinity && monthArr[1] !== 0 && yearArr.length === 0) {\n    filteredData = data.filter(\n      (element) =>\n        Number(element.time.slice(0, 4)) === date.getFullYear() &&\n        Number(element.time.slice(5, 7)) <= Number(monthArr[1]) &&\n        Number(element.time.slice(5, 7)) >= Number(monthArr[0])\n    );\n  }\n\n  // if having year-base array, then only need to check 1) year\n  if (yearArr.length !== 0) {\n    filteredData = data.filter((element) =>\n      yearArr.includes(element.time.slice(0, 4))\n    );\n  }\n\n  return filteredData;\n}\n*/\n"]},"metadata":{},"sourceType":"module"}