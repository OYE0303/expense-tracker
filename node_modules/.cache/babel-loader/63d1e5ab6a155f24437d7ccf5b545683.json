{"ast":null,"code":"import coerceNumber from \"./CoerceNumber/coerceNumber\";\nimport createYearMonthDay from \"./CreateYearMonthDay/createYearMonthDay\"; // Reference 1\n\nfunction compareTime(data, dateObj, endingYear, endingMonth, endingDay) {\n  const {\n    year: dataYear,\n    month: dataMonth,\n    day: dataDay\n  } = data;\n  const [year, month, day, endingYearNum, endingMonthNum, endingDayNum] = coerceNumber(dataYear, dataMonth, dataDay, endingYear, endingMonth, endingDay);\n  if (!dateObj) return year < endingYearNum || year === endingYearNum && month < endingMonthNum || year === endingYearNum && month === endingMonthNum && day <= endingDayNum;else {\n    const [endingYear, endingMonth, endingDay] = createYearMonthDay(dateObj);\n    return year < endingYear || year === endingYear && month < endingMonth || year === endingYear && month === endingMonth && day <= endingDay;\n  }\n}\n\nexport default compareTime;\n/*\nReference 1\nThe logic is \n1. If the year of data is less than current year, we can guarantee this data is within the range, so immediately return true\n2. If both year are the same, then need to compare month and day\n*/","map":{"version":3,"sources":["/Users/eyo/Desktop/expense-tracker/src/Others/compareTime.js"],"names":["coerceNumber","createYearMonthDay","compareTime","data","dateObj","endingYear","endingMonth","endingDay","year","dataYear","month","dataMonth","day","dataDay","endingYearNum","endingMonthNum","endingDayNum"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,6BAAzB;AACA,OAAOC,kBAAP,MAA+B,yCAA/B,C,CAEA;;AACA,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,OAA3B,EAAoCC,UAApC,EAAgDC,WAAhD,EAA6DC,SAA7D,EAAwE;AACtE,QAAM;AAAEC,IAAAA,IAAI,EAAEC,QAAR;AAAkBC,IAAAA,KAAK,EAAEC,SAAzB;AAAoCC,IAAAA,GAAG,EAAEC;AAAzC,MAAqDV,IAA3D;AACA,QAAM,CAACK,IAAD,EAAOE,KAAP,EAAcE,GAAd,EAAmBE,aAAnB,EAAkCC,cAAlC,EAAkDC,YAAlD,IACJhB,YAAY,CACVS,QADU,EAEVE,SAFU,EAGVE,OAHU,EAIVR,UAJU,EAKVC,WALU,EAMVC,SANU,CADd;AAUA,MAAI,CAACH,OAAL,EACE,OACEI,IAAI,GAAGM,aAAP,IACCN,IAAI,KAAKM,aAAT,IAA0BJ,KAAK,GAAGK,cADnC,IAECP,IAAI,KAAKM,aAAT,IACCJ,KAAK,KAAKK,cADX,IAECH,GAAG,IAAII,YALX,CADF,KAQK;AACH,UAAM,CAACX,UAAD,EAAaC,WAAb,EAA0BC,SAA1B,IAAuCN,kBAAkB,CAACG,OAAD,CAA/D;AAEA,WACEI,IAAI,GAAGH,UAAP,IACCG,IAAI,KAAKH,UAAT,IAAuBK,KAAK,GAAGJ,WADhC,IAECE,IAAI,KAAKH,UAAT,IAAuBK,KAAK,KAAKJ,WAAjC,IAAgDM,GAAG,IAAIL,SAH1D;AAKD;AACF;;AAED,eAAeL,WAAf;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import coerceNumber from \"./CoerceNumber/coerceNumber\";\nimport createYearMonthDay from \"./CreateYearMonthDay/createYearMonthDay\";\n\n// Reference 1\nfunction compareTime(data, dateObj, endingYear, endingMonth, endingDay) {\n  const { year: dataYear, month: dataMonth, day: dataDay } = data;\n  const [year, month, day, endingYearNum, endingMonthNum, endingDayNum] =\n    coerceNumber(\n      dataYear,\n      dataMonth,\n      dataDay,\n      endingYear,\n      endingMonth,\n      endingDay\n    );\n\n  if (!dateObj)\n    return (\n      year < endingYearNum ||\n      (year === endingYearNum && month < endingMonthNum) ||\n      (year === endingYearNum &&\n        month === endingMonthNum &&\n        day <= endingDayNum)\n    );\n  else {\n    const [endingYear, endingMonth, endingDay] = createYearMonthDay(dateObj);\n\n    return (\n      year < endingYear ||\n      (year === endingYear && month < endingMonth) ||\n      (year === endingYear && month === endingMonth && day <= endingDay)\n    );\n  }\n}\n\nexport default compareTime;\n/*\nReference 1\nThe logic is \n1. If the year of data is less than current year, we can guarantee this data is within the range, so immediately return true\n2. If both year are the same, then need to compare month and day\n*/\n"]},"metadata":{},"sourceType":"module"}