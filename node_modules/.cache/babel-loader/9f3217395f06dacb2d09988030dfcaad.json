{"ast":null,"code":"/*\nThe logic is \n1. If the year of data is less than current year, we can guarantee this data is within the range, so immediately return true\n2. If both year are the same, then need to compare month and day\n\nNote that we do NOT use any explicit coercion \nBecause we can make sure that\n1) the value in data object are always string (from form)\n2) assume curYear, curMonth and curDay are either string or number\n\nRecall the rull of comparison operator\nfor both \"<\" and \">\"\nIf both of value are string, it directly compares character by character\n=> \"01\" > \"10\" -> true, \"05\" < \"01\" -> true\nIf one of value is string, and the other one is number, then it converts both value to number, and do the comparison\n\nSo the reason without explicit coercion is because we're familiar with these rulls\n*/\nfunction compareTime(data, dateObj, curYear, curMonth, curDay) {\n  const {\n    year,\n    month,\n    day\n  } = data;\n  const curYear1 = dateObj.getFullYear(),\n        curMonth1 = dateObj.getMonth() + 1;\n  if (!dateObj) return year < curYear || year === curYear && month < curMonth || year === curYear && month === curMonth && day <= curDay;else return year - 0 < curYear1 || year - 0 === curYear1 && month - 0 < curMonth1 || year - 0 === curYear1 && month - 0 === curMonth1 && day - 0 <= dateObj.getDate();\n}\n\nexport default compareTime;","map":{"version":3,"sources":["/Users/eyo/Desktop/project-expenseTracker-main/src/Others/compareTime.js"],"names":["compareTime","data","dateObj","curYear","curMonth","curDay","year","month","day","curYear1","getFullYear","curMonth1","getMonth","getDate"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAT,CAAqBC,IAArB,EAA2BC,OAA3B,EAAoCC,OAApC,EAA6CC,QAA7C,EAAuDC,MAAvD,EAA+D;AAC7D,QAAM;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,KAAR;AAAeC,IAAAA;AAAf,MAAuBP,IAA7B;AAEA,QAAMQ,QAAQ,GAAGP,OAAO,CAACQ,WAAR,EAAjB;AAAA,QACEC,SAAS,GAAGT,OAAO,CAACU,QAAR,KAAqB,CADnC;AAGA,MAAI,CAACV,OAAL,EACE,OACEI,IAAI,GAAGH,OAAP,IACCG,IAAI,KAAKH,OAAT,IAAoBI,KAAK,GAAGH,QAD7B,IAECE,IAAI,KAAKH,OAAT,IAAoBI,KAAK,KAAKH,QAA9B,IAA0CI,GAAG,IAAIH,MAHpD,CADF,KAOE,OACEC,IAAI,GAAG,CAAP,GAAWG,QAAX,IACCH,IAAI,GAAG,CAAP,KAAaG,QAAb,IAAyBF,KAAK,GAAG,CAAR,GAAYI,SADtC,IAECL,IAAI,GAAG,CAAP,KAAaG,QAAb,IACCF,KAAK,GAAG,CAAR,KAAcI,SADf,IAECH,GAAG,GAAG,CAAN,IAAWN,OAAO,CAACW,OAAR,EALf;AAOH;;AAED,eAAeb,WAAf","sourcesContent":["/*\nThe logic is \n1. If the year of data is less than current year, we can guarantee this data is within the range, so immediately return true\n2. If both year are the same, then need to compare month and day\n\nNote that we do NOT use any explicit coercion \nBecause we can make sure that\n1) the value in data object are always string (from form)\n2) assume curYear, curMonth and curDay are either string or number\n\nRecall the rull of comparison operator\nfor both \"<\" and \">\"\nIf both of value are string, it directly compares character by character\n=> \"01\" > \"10\" -> true, \"05\" < \"01\" -> true\nIf one of value is string, and the other one is number, then it converts both value to number, and do the comparison\n\nSo the reason without explicit coercion is because we're familiar with these rulls\n*/\nfunction compareTime(data, dateObj, curYear, curMonth, curDay) {\n  const { year, month, day } = data;\n\n  const curYear1 = dateObj.getFullYear(),\n    curMonth1 = dateObj.getMonth() + 1;\n\n  if (!dateObj)\n    return (\n      year < curYear ||\n      (year === curYear && month < curMonth) ||\n      (year === curYear && month === curMonth && day <= curDay)\n    );\n  else\n    return (\n      year - 0 < curYear1 ||\n      (year - 0 === curYear1 && month - 0 < curMonth1) ||\n      (year - 0 === curYear1 &&\n        month - 0 === curMonth1 &&\n        day - 0 <= dateObj.getDate())\n    );\n}\n\nexport default compareTime;\n"]},"metadata":{},"sourceType":"module"}